import os
import pandas as pd
import scan_traffic as ids
from sklearn.model_selection import train_test_split
import time
import numpy as np
import joblib
from collections import Counter
import torch.utils.data
from torch.utils.data import Dataset, DataLoader
import torch
import torch.nn as nn
import pickle
from sklearn.metrics import accuracy_score, precision_score, recall_score
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import Normalizer
import joblib
from sklearn.model_selection import train_test_split


class CustomDataset(Dataset):
    def __init__(self, X, Y=None):
        self.X = X
        self.Y = Y

    def __getitem__(self, index):
        if self.Y is not None:
            return torch.tensor(self.X[index]), torch.tensor(self.Y[index])
        else:
            return torch.tensor(self.X[index],dtype=torch.float32)
    def __len__(self):
        return len(self.X)

class CustomLstmDataset(Dataset):
    def __init__(self, X, Y=None):
        self.X = X
        self.Y = Y

    def __getitem__(self, index):
        x_pd = self.X[index]
        input_ = torch.tensor(x_pd.values.tolist()).float()

        if self.Y is not None:
            y_pd = self.Y[index]
            label = torch.tensor(y_pd.values,tolist()).float()
            return input_, label
        else:
            return input_

    def __len__(self):
        return len(self.X)

def attack_list (y_rf_traffic, y_nn_traffic, traffic):
        attack_ip_list = []
        for i in range(0, len(y_rf_traffic)):
            if not (y_rf_traffic[i] == 0 and y_nn_traffic[i] == 0):
            #if (y_rf_traffic[i] == 0 and y_nn_traffic[i] == 0):
                attack_ip_list.append((traffic['ip'][i],traffic['mac'][i], traffic['t_port'][i], traffic['d_port'][i]))
                
        return attack_ip_list
        
def check_attack(traffic, x_seq):
    x = traffic.drop(['ip', 'mac','t_port', 'd_port'], axis = 1)
    seq_list = x_seq
    for i in range(0, len(x_seq)):
        x_seq[i] = x_seq[i].drop(['ip', 'mac','t_port', 'd_port', 'proto'], axis = 1)
    print(x)
    x = data_scaling(x)
    print(x)
    rf_model = joblib.load('./model/rf_model.h5')
    knn_model = joblib.load('./model/knn_model.h5')
    y_knn_traffic = knn_model.predict(x)
    print("knn end")
    y_rf_traffic = rf_model.predict(x)
    print("rf end")
    x = x.values
    y_nn_traffic = predict_nn(x)
    print("nn end")
    #del traffic
    del x
    attack_ip_list = attack_list(y_rf_traffic,y_nn_traffic,traffic)
    if len(attack_ip_list) == 0:
        return 0, 0
    
    #attack_ip_list = list(set(attack_ip_list)) # deduplication
    cnt = 0
    for i in y_knn_traffic:
        if not i == 0:
            cnt = cnt + 1
    print(cnt/len(traffic))
    cnt = 0
    for i in y_rf_traffic:
        if not i == 0:
            cnt = cnt + 1
    print(y_knn_traffic)
    print(cnt/len(traffic))
    
    cnt = 0
    for i in y_nn_traffic:
        if not i == 0:
            cnt = cnt + 1
    print(cnt/len(traffic))
    
    #print(len(attack_ip_list)/len(traffic))
    
    #x_seq = seq_data_preprocessing(attack_ip_list, seq_list)
    #del attack_ip_list
    #print("attack ip list")
    y_lstm_traffic = predict_lstm(x_seq)
    print("lstm end")
    atk_df = decision_seq_attack(seq_list, y_lstm_traffic)
    
    #del x_seq
    #del y_lstm_traffic

    result = 0
    if not len(atk_df) == 0:
        result = 1
        
    cnt = 0
    for i in y_lstm_traffic:
        if not i == 0:
            cnt = cnt + 1
    accuracy_model(x_seq, y_lstm_traffic)
    
    print(atk_df)
    
    return atk_df, result
    
def accuracy_model(x_seq, y_lstm_traffic):
    t_cnt = 0
    a_cnt = 0
    
    for idx in range(0, len(x_seq)):  # dataframe
        for col_idx in range (0, len(x_seq[idx])):  # col
            if x_seq[idx]['length'][col_idx] == 0:
                break
            else:
                if not y_lstm_traffic [idx*20 + col_idx] == 0:
                #if y_lstm_traffic [idx*20 + col_idx] == 0:  # normal
                    a_cnt = a_cnt + 1
                t_cnt = t_cnt + 1
    print("O: "+ str(a_cnt) + " X: " + str(t_cnt-a_cnt))
    print("Accuracy : " + str(a_cnt/t_cnt))
               
    

def decision_seq_attack(x_seq, y_lstm_traffic):
    idx = 0
    atk_df = pd.DataFrame(columns=['ip', 'mac', 't_port', 'd_port'])
    for attack_ip in x_seq:
        atk_cnt = 0
        for traffic in range(0, len(attack_ip)):
            if not y_lstm_traffic[idx] == 0:
                atk_cnt = atk_cnt + 1
            idx = idx + 1
        if atk_cnt/len(attack_ip) > 0.8:
            atk_df.loc[len(atk_df)] = [attack_ip['ip'][0], attack_ip['mac'][0], attack_ip['t_port'][0], attack_ip['d_port'][0]]

    return atk_df
            


def seq_data_preprocessing(attack_ip_list, x_seq):
    attack_seq_list = []

    for traffic_ip in x_seq:
        for attacked_ip in attack_ip_list:
           if (traffic_ip['ip'][0], traffic_ip['t_port'][0], traffic_ip['d_port'][0]) == attacked_ip:
                attack_seq_list.append(traffic_ip)
                break

    return attack_seq_list
        

def predict_lstm(x_seq):
    lstm_model = torch.load("./model/lstm_model.pt")
    lstm_model.eval()
    pred_dataset = CustomLstmDataset(x_seq)
    pred_loader = DataLoader(pred_dataset, batch_size=7*20*100, shuffle=False, num_workers=0)
    pred = inference(lstm_model,pred_loader)
    result = lstm_classification(pred)
    
    return result

def predict_nn(x):
    nn_model = torch.load("./model/nn_model.pt")
    nn_model.eval()
    pred_dataset = CustomDataset(x)
    pred_loader = DataLoader(pred_dataset, batch_size=60, shuffle=False)
    pred = inference(nn_model, pred_loader)
    result = nn_classification(pred)

    return result
    
def lstm_classification(pred):
    result = []
    pred = sum(sum(pred, []),[])
    for i in pred:
        if i <0.5:
            result.append(0)
        elif i < 1.5:
            result.append(1)
        elif i < 2.5:
            result.append(2)
        else:
            result.append(-1)

    return result

def inference(model, pred_loader):
    model.eval()
    pred = []
    with torch.no_grad():
        for X in pred_loader:
            output = model(X)
            pred.extend(output.cpu().tolist())
    return pred

def nn_classification(pred):
    result = []
    attack_ip_list = []
    for i in range(0, len(pred)):
        if pred[i][0]<0.5:
            result.append(0)
        elif pred[i][0]<1.5:
            result.append(1)
        elif pred[i][0] <2.5:
            result.append(2)
        else:
            result.append(-1)

    return result


def data_scaling(x):
    norm = Normalizer()
    x = norm.fit_transform(x)
    norm.fit(x)
    x = pd.DataFrame(x, columns=['weak_port', 'proto', 'total_length', 'time', 'datarate', 'cnt'])
    return x
