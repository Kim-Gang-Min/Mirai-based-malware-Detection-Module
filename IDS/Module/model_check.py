import os
import pandas as pd
import scan_traffic as ids
from sklearn.model_selection import train_test_split
import time
import numpy as np
import joblib
from collections import Counter
import xgboost as xgb
import torch.utils.data
import Dataset, DataLoader
import torch
import torch.nn as nn
import pickle
from sklearn.metrics import accuracy_score, precision_score, recall_score
from sklearn.ensemble import RandomForestClassifier
import matplotlib.pyplot as plt
from sklearn.preprocessing import Normalizer
import seaborn as sns
import joblib
from sklearn.model_selection import train_test_split

#import tensorflow as tf
str_attack = ['normal', 'scan', 'server']

class CustomDataset(Dataset):
    def __init__(self, X, Y=None):
        self.X = X
        self.Y = Y

    def __getitem__(self, index):
        if self.Y is not None:
            return torch.Tensor(self.X[index]), torch.Tensor(self.Y[index])
        else:
            return torch,Tensor(self.X[index])

    def __len__(self):
        return len(self.X)

class CumstomLstmDataset(Dataset):
    def __init__(self, X, Y=None):
        self.X = X
        self.Y = Y

    def __getitem(self, index):
        x_pd = self.X[index]
        input_ = torch.tensor(x_pd.values.tolist()).float()

        if self.Y is not None:
            y_pd = self.Y[index]
            label = torch.tensor(y_pd.values,tolist()).float()
            return input_, label
        else:
            return input_

    def __len__(self):
        return len(self.X)


def check_attack(traffic, seq_list):
    x = traffic.drop(['ip', 'mac','t_port', 'd_port'], axis = 1)
    
    rf_model = joblib.load('./model/rf_model.h5')
    nn_model = torch.load("./model/nn_model.pt")
    
    y_rf_traffic = rf_model.predict(x)
    nn_model.eval()
    y_nn_traffic, attack_ip_list = predict_nn(traffic, x)

    del traffic
    del x

    if len(attack_ip_list) == 0:
        return 0, 0

    attack_ip_list = list(set(attack_ip_list)) # deduplication

    x_seq = seq_data_preprocessing(attack_ip_list, x_seq)
    
    del attack_ip_list

    y_lstm_traffic = predict_lstm(x_seq)
    atk_df = decision_seq_attack(x_seq, y_lstm_traffic)
    
    del x_seq
    del y_lstm_traffic

    result = 0
    if not len(atk_df) == 0:
        result = 1
    
    return atk_df, result
    

def decision_seq_attack(x_seq, y_lstm_traffic):
    idx = 0
    atk_df = pd.DataFrame(columns=['ip', 'mac', 't_port', 'd_port'])
    for attack_ip in x_seq:
        atk_cnt = 0
        for traffic in range(0, len(attack_ip)):
            if not y_lstm_traffic[idx] == 0:
                atk_cnt = atk_cnt + 1
            idx = idx + 1
        if atk_cnt/len(attack_ip) > 0.8:
            atk_df.loc[len(atk_df)] = [attack_ip['ip'][0], attack_ip['mac'][0], attack_ip['t_port'][0], attack_ip['d_port'][0]]

    return atk_df
            


def seq_data_preprocessing(attack_ip_list, x_seq):
    attack_seq_list = []

    for traffic_ip in x_seq:
        for attacked_ip in attack_ip_list:
           if (traffic_ip['ip'][0], traffic_ip['t_port'][0], traffic_ip['d_port'][0]) == attacked_ip:
                attack_seq_list.append(traffic_ip)
                break

    return attack_seq_list
        

def predict_lstm(x_seq):
    lstm_model = torch.load("./model/lstm_model.pt")
    pred_dataset = CustomLstmDastaset(x)
    pred_loader = DataLoader(pred_dataset, batch_size=7*15, shuffle=False)
    pred = inference(lstm_model,pred_loader)
    result = lstm_classification(pred)
    
    return result

def predict_nn(traffic, x):
    nn_model = torch.load("./nn_model.pt")
    pred_dataset = CustomDataset(x)
    pred_loader = DataLoader(pred_dataset, batch_size=60, shuffle=False)
    pred = inference(nn_model, pred_loader)
    result,attack_ip_list = nn_classification(pred)

    return result, attack_ip_list

def lstm_classification(pred):
    result = []
    for i in pred:
        if i <0.5:
            result.append(0)
        elif i < 1.5:
            result.append(1)
        elif i < 2.5:
            result.append(2)
        else:
            result.append(-1)

    return result

def inference(model, pred_loader):
    model.eval()
    pred = []
    with torch.no_grad():
        for X in pred_loader:
            output = model(X)
            pred.extend(output.cpu().tolist())
    return pred

def nn_classification(traffic, pred):
    result = []
    attack_seq_list = []
    for i in range(pred):
        if pred[i][0]<0.5:
            result.append(0)
        elif pred[i][0]<1.5:
            attack_seq_list.append((traffic['ip'][i],traffic['mac'][i], traffic['t_port'][i], traffic['dport'][i]))
            result.append(1)
        elif pred[i][0] <2.5:
            attack_seq_list.append((traffic['ip'][i],traffic['mac'][i], traffic['t_port'][i], traffic['dport'][i]))
            result.append(2)
        else:
            result.append(-1)

    return result, attack_ip_list



